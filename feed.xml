<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
<channel>
<title>Alex&#39;s website</title>
<link>https://muscar.eu/</link>
<description>I try to make computers do cool things. Sometimes I succeed.</description>
<managingEditor>[email protected] (Alex Muscar)</managingEditor>
<pubDate>Thu, 04 Jan 2024 16:24:44 +0000</pubDate>
<item>
<title>A simple problem that isn't</title>
<link>https://muscar.eu/posts/bitset-iter.html</link>
<description>A simple problem that isn't</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">A simple problem that isn’t</h1>
<p class="author">Alex Muscar</p>
<p class="date">January 4, 2023</p>
</header>
<p>Some problems seem simple at first blush. Recently, I wanted to add
an iterator to a bit set implemented in Go. The bit set implementation
itself is what you’d expect. I lifted it from section 6.5 of <a
href="https://www.goodreads.com/book/show/25080953-the-go-programming-language">“The
Go Programming Language”</a>.</p>
<p>You can find the code for this post <a
href="https://github.com/muscar/bit-sets">here</a>.</p>
<p>Have a look at the <a
href="https://github.com/muscar/bit-sets/blob/main/internal/bitset/bitset.go#L31">implementation</a>
of <code>BitSet</code> before you read on. The code in this post is
written for bit sets represented using 64 bit words. That’s why you’ll
see the magic constant 64 all over the shop.</p>
<h2 id="a-problem-specification">A problem specification</h2>
<p>Given the following specification:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Iterator <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Next tries to advance the iterator to the next value in the set.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// It returns `true` if there was a next value, `false` otherwise.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Next must be called *before* the first call to Current.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    Next<span class="op">()</span> <span class="dt">bool</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Current returns the element of the set that the iterator is pointing at.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    Current<span class="op">()</span> <span class="dt">int</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>how would you implement an iterator for the bit set?</p>
<h2 id="the-straightforward-implementation">The straightforward
implementation</h2>
<p>In languages with built-in support for generators, the solution is
straightforward. Here’s a C# implementation:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode csharp"><code class="sourceCode cs"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> IEnumerable<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="fu">NaiveIter</span><span class="op">()</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> <span class="op">(</span><span class="dt">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> words<span class="op">.</span><span class="fu">Length</span> <span class="op">*</span> <span class="dv">64</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span><span class="fu">Has</span><span class="op">(</span>i<span class="op">))</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">yield</span> <span class="kw">return</span> i<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Since Go doesn’t have generators, we have to roll our own. That’s not
too hard, though. We just need to remember where we left off on the
previous iteration of the loop, and pick up from there. At this point,
someone is bound to suggest using channels. But channels aren’t free as
we’ll see in the <a href="#benchmarks">benchmarks</a> section.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> NaiveIter <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    s   <span class="op">*</span>BitSet</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    off <span class="dt">int</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>BitSet<span class="op">)</span> Iter<span class="op">()</span> <span class="op">*</span>NaiveIter <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>Iter<span class="op">{</span>s<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>NaiveIter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    it<span class="op">.</span>off<span class="op">++</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>off <span class="op">&lt;</span> it<span class="op">.</span>s<span class="op">.</span>Cap<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>it<span class="op">.</span>s<span class="op">.</span>Has<span class="op">(</span>it<span class="op">.</span>off<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>off<span class="op">++</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it<span class="op">.</span>off <span class="op">&lt;</span> it<span class="op">.</span>s<span class="op">.</span>Cap<span class="op">()</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>NaiveIter<span class="op">)</span> Current<span class="op">()</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it<span class="op">.</span>off</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are two things to note about this iterator. First, we
initialize <code>off</code> to -1–we start just before the first
element. Second, we increment <code>it.off</code> <em>before</em> the
loop.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> We want to make progress on every
call to <code>Next</code>. <a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a><sup>,</sup> <a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></p>
<p>Both the C# and the Go iterator have the same problem, though: they
don’t handle sparse bit sets very efficiently.</p>
<h2 id="an-implementation-that-deals-with-sparse-bit-sets">An
implementation that deals with sparse bit sets</h2>
<p>Let’s try to clarify the problem we are solving: we have a bit set
represented as an array of words; the set is sparse, so we have long
runs of zeroes; we don’t want to look at every single zero bit.</p>
<p>The obvious approach is to skip consecutive zeroes. Given the set’s
representation, it seems sensible to try to skip entire words if they
are zero. But, as with many simple ideas, the devil is in the details.
You’ve seen the straightforward implementation. How would you implement
an optimised iterator?</p>
<h3 id="a-first-try">A first try</h3>
<p>In addition to the offset of the current bit in a word, the optimised
iterator tracks the offset of the current word. Tracking it will help us
skip zero words. The data structure now looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Iter <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    s          <span class="op">*</span>BitSet</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    woff<span class="op">,</span> boff <span class="dt">int</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>BitSet<span class="op">)</span> Iter<span class="op">()</span> <span class="op">*</span>Iter <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>Iter<span class="op">{</span>s<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The iterator is initially positioned just before the first bit of the
first word.</p>
<p>Getting the current element is easy. It’s just the inverse of the
formula in <code>Add</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Current<span class="op">()</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> it<span class="op">.</span>woff<span class="op">*</span><span class="dv">64</span> <span class="op">+</span> it<span class="op">.</span>boff</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now for the interesting part, the implementation of
<code>Next</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span></code></pre></div>
<p>We start by tackling the termination condition. If there are no more
words to check in the set representation, we are done:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> it<span class="op">.</span>woff <span class="op">&gt;=</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Next, we want to make progress. We can pretty much take the loop from
the previous implementation, and adapt it slightly:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ensure we make progress</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// find the least significant one bit in the current word</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>it<span class="op">.</span>boff<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>This loop looks for the least significant one bit in the current
word. When it terminates, one of two conditions holds: either
<code>it.boff</code> is 64–all the bits were zero–and we need to move to
the next non-zero word. Or we’ve found a one bit, and we found the next
element.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we found the next element</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    it<span class="op">.</span>boff <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>When this second loop terminates it’s either because we ran out of
words– we found all the elements, we return <code>false</code>. Or
because we found a non-zero word, and we’re not done yet. We’re
positioned at the beginning of a word, but we still have to find the
least significant one bit.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we found all the elements</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> it<span class="op">.</span>woff <span class="op">&gt;=</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// we found a non-zero word; find the least significant bit</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>it<span class="op">.</span>boff<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And with this, we’re done. But the code could be nicer.</p>
<h3 id="improving-the-code">Improving the code</h3>
<p><code>Next</code>’s epilogue is almost identical to its prologue.
Let’s start there. We <em>could</em> replace the final <code>if</code>
and <code>for</code> statements with a jump to the top of the
function–they do the same thing.<a href="#fn4" class="footnote-ref"
id="fnref4" role="doc-noteref"><sup>4</sup></a> And in some cases
<code>goto</code>s are not that harmful. But here it’s just an unguarded
loop in disguise.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we&#39;re done with the whole set</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>woff <span class="op">&gt;=</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ensure we make progress</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find the least significant one bit in the current word</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>it<span class="op">.</span>boff<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we found a set bit</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Did you notice it? We’re resetting <code>it.boff</code> to -1, not 0,
like in the previous version. That’s because we advance
<code>it.boff</code> before the bit scanning loop.</p>
<p>We can further clean this up by merging the first <code>if</code>
with the outer <code>for</code>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ensure we make progress</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find the least significant one bit in the current word</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>it<span class="op">.</span>boff<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we found the next element</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>But do we need to skip all the zero words at once? No, we can let the
main loop do it word by word–it’s already doing that with
<code>it.woff++</code>. If we refactor the bit scanning loop just
slightly, we can test for zero words, and get rid of the final
<code>for</code>.</p>
<p>The <code>it.woff &lt; len(it.s.words)</code> check is covered by the
main loop. We just need to roll <code>it.s.words[it.woff] == 0</code>
into the bit scanning loop’s condition. But <code>it.boff &lt; 64</code>
and <code>it.s.words[it.woff] == 0</code> check almost the same thing:
the (remaining) sub-interval is empty.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// </span><span class="al">NOTE</span><span class="co">: wrong!</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>NotGreatIter1<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ensure we make progress</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find the least significant bit in the current word</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]&amp;(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>it<span class="op">.</span>boff<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we found a set bit</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>boff <span class="op">&lt;</span> <span class="dv">64</span> <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The comment gives it away, this version doesn’t work. It’s going to
get stuck in an infinite loop because <code>it.s.words[it.woff]</code>
never changes. We can address this by keeping a copy of the current word
that we shift right as we scan it. It will eventually become zero, and
as a nice bonus we have the next bit to check handy as the least
significant bit in the word.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Iter <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    s          <span class="op">*</span>BitSet</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    word       <span class="dt">uint64</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    woff<span class="op">,</span> boff <span class="dt">int</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>BitSet<span class="op">)</span> Iter<span class="op">()</span> <span class="op">*</span>Iter <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>Iter<span class="op">{</span>s<span class="op">,</span> s<span class="op">.</span>words<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ensure we make progress</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find the least significant bit in the current word</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>word <span class="op">!=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>word<span class="op">&amp;</span><span class="dv">0x01</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>word <span class="op">&gt;&gt;=</span> <span class="dv">1</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we found a set bit</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>word <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>word <span class="op">&gt;&gt;=</span> <span class="dv">1</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>word <span class="op">=</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Not only is the code cleaner, but it’s also more efficient. The inner
loop test got cheaper: we compare the current word with zero, and only
check the least significant bit instead of building the mask on the fly
by shifting.<a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a></p>
<p>Notice that <code>it.word &gt;&gt;= 1</code> just before we return
<code>true</code>? Because we exit the bit scanning loop <em>before</em>
we shift the current word right, in the next iteration we’d be looking
at the same bit. This is another one of those “ensure we make progress”
measures.</p>
<p>There’s one more problem to solve. On the very last go around the
loop, we’ll do an out-of-bounds read from the <code>it.s.words</code>
array. We could add an explicit check, but that’s a price we pay on
every iteration of the loop for a case that only happens once. Not
great.</p>
<p>Instead, we pad the words array. We allocate one extra word that gets
read during the last iteration of the loop. And we update the main loop
condition to take into account the padding.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>it <span class="op">*</span>Iter<span class="op">)</span> Next<span class="op">()</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> it<span class="op">.</span>woff <span class="op">&lt;</span> <span class="bu">len</span><span class="op">(</span>it<span class="op">.</span>s<span class="op">.</span>words<span class="op">)-</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ensure we make progress</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find the least significant bit in the current word</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> it<span class="op">.</span>word <span class="op">!=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> it<span class="op">.</span>word<span class="op">&amp;</span><span class="dv">0x01</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>boff<span class="op">++</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>word <span class="op">&gt;&gt;=</span> <span class="dv">1</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we found a set bit</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> it<span class="op">.</span>word <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>            it<span class="op">.</span>word <span class="op">&gt;&gt;=</span> <span class="dv">1</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">true</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we need to find the next non-zero word</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>boff <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>woff<span class="op">++</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        it<span class="op">.</span>word <span class="op">=</span> it<span class="op">.</span>s<span class="op">.</span>words<span class="op">[</span>it<span class="op">.</span>woff<span class="op">]</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">false</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We’re done. We have an iterator that should handle sparse sets
efficiently. But how efficient is it compared to the naive iterator we
started with?</p>
<h3 id="benchmarks">Benchmarks</h3>
<p>I ran several benchmarks on my ageing 2014 macbook pro. All the
benchmarks use a set with room for 1000000 elements with various load
factors. The benchmarks just iterate over the elements and sum them
up.</p>
<p>I’ve also implemented the naive and optimised versions of the
iterators with channels for the benchmarks. You can find the code for
the implementations and the benchmarks in the <a
href="https://github.com/muscar/bit-sets">repo</a>. The benchmark names
should be fairly obvious: the part after “Benchmark” is the iterator
flavour; “Dense” means the set if full, while “SparseN” means the set
has every N<sup>th</sup> element set. So, for example,
“BenchmarkOptIterSparse1000” benchmarks the optimised implementation of
the iterator with every 1000<sup>th</sup> element set. That’s a 0.1%
load factor.</p>
<p>Let’s look at the results:</p>
<pre><code>cpu: Intel(R) Core(TM) i5-4278U CPU @ 2.60GHz
BenchmarkNaiveIterDense-4                    271       4004419 ns/op         483 B/op          0 allocs/op
BenchmarkOptIterDense-4                      364       3880946 ns/op         360 B/op          0 allocs/op
BenchmarkChanNaiveIterDense-4                  5     249094165 ns/op       26360 B/op          2 allocs/op
BenchmarkChanOptIterDense-4                    5     223480939 ns/op       26584 B/op          3 allocs/op
BenchmarkNaiveIterSparse100-4                382       3168522 ns/op         343 B/op          0 allocs/op
BenchmarkOptIterSparse100-4                 1482        880012 ns/op          88 B/op          0 allocs/op
BenchmarkNaiveIterSparse1000-4               391       3078779 ns/op         335 B/op          0 allocs/op
BenchmarkOptIterSparse1000-4                8874        122877 ns/op          14 B/op          0 allocs/op
BenchmarkNaiveIterSparse10000-4              394       3052418 ns/op         332 B/op          0 allocs/op
BenchmarkOptIterSparse10000-4              24816         48760 ns/op           5 B/op          0 allocs/op
BenchmarkChanNaiveIterSparse100-4            182       6479458 ns/op         864 B/op          2 allocs/op
BenchmarkChanOptIterSparse100-4              452       2969189 ns/op         430 B/op          2 allocs/op
BenchmarkChanNaiveIterSparse1000-4           312       3826812 ns/op         562 B/op          2 allocs/op
BenchmarkChanOptIterSparse1000-4            3910        290776 ns/op         172 B/op          2 allocs/op
BenchmarkChanNaiveIterSparse10000-4          354       4126216 ns/op         506 B/op          2 allocs/op
BenchmarkChanOptIterSparse10000-4          24386         49496 ns/op         141 B/op          2 allocs/op</code></pre>
<p>For full sets, the naive and optimised iterators are in the same
ballpark. The optimised iterator tended to come faster in most runs, but
the difference is most likely down to noise.</p>
<p>The channel implementations on the other hand were about 70 times
slower. While I expected using channels to come with a performance
penalty, this is more expensive than I would have guessed.</p>
<p>As the load factor decreases, and we have longer zero spans, the
optimised iterator does consistently better. The naive implementation
takes about the same time for every run, which is not surprising.</p>
<p>The channel iterators get significantly faster. The optimised
implementation is faster than the naive non-channel implementation when
the load factor is 0.1%.</p>
<h2 id="conclusions">Conclusions</h2>
<p>What did we learn? First, that seemingly simple problems, can get
quite tricky when you try to implement them. For me, the devil was in
the details with this algorithm. Trying to get all the edge cases right
took some time and fiddling with the code.</p>
<p>Second, you can start with a less than ideal algorithm, and
iteratively improve it by a combination of insight and (almost)
mechanical transformations.</p>
<p>Third, tools matter. It took me about 5 minutes to write the C#
implementation of the optimised algorithm:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode csharp"><code class="sourceCode cs"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> IEnumerable<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="fu">OptIter</span><span class="op">()</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> <span class="op">(</span><span class="dt">var</span> word <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> word <span class="op">&lt;</span> words<span class="op">.</span><span class="fu">Length</span><span class="op">;</span> word<span class="op">++)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> segment <span class="op">=</span> words<span class="op">[</span>word<span class="op">];</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> <span class="op">(</span><span class="dt">var</span> bit <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> segment <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> bit<span class="op">++,</span> segment <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> <span class="op">((</span>segment <span class="op">&amp;</span> <span class="bn">0x01</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>                <span class="kw">yield</span> <span class="kw">return</span> word <span class="op">*</span> <span class="dv">64</span> <span class="op">+</span> bit<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Granted, this was after I’d already written the Go implementation. It
took somewhat longer to come up with the optimised version in Go.</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>If we initialize <code>off</code> to
0, we skip the very first element in the set. That’s why we have to call
<code>Next</code> before the first call to <code>Current</code>.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>If we leave out <code>it.off++</code>
before the loop, the iterator gets stuck on the first element in the
set.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>This duplication is somewhat
unfortunate, but we have to do it like this because Go lacks C’s
<code>do/while</code> or Pascal’s <code>repeat/until</code>.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Well, not quite the same. The loop in
the preamble does one extra test per iteration.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>We could further move the
<code>it.boff++</code> statements in the inner <code>for</code> loop.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Wed, 04 Jan 2023 13:00:00 +0000</pubDate>
</item>
<item>
<title>A verified algorithm for determining the intersection point of two lists in O(1) space</title>
<link>https://muscar.eu/posts/linked-list-intersection-proof.html</link>
<description>A verified algorithm for determining the intersection point of two lists in O(1) space</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">A verified algorithm for determining the intersection
point of two lists in O(1) space</h1>
<p class="author">Alex Muscar</p>
<p class="date">July 2, 2022</p>
</header>
<p>Okay, this post has been a long time coming. Initially I meant it to
cover a generalisation of the the algorithm we developed <a
href="/linked-list-intersection.html">last time</a>. The plan was to do
a hand wavy proof of correctness, and take hints from the proof process
to come up with a more generic version of the algorithm.</p>
<p>That’s still the plan, but I wasn’t happy with the hand wavy part. So
I decided to do a proper proof. But if something’s worth doing it’s
definitely worth overdoing. Right? And that’s how I ended up writing a
verified version of the algorithm in <a
href="https://dafny.org/">Dafny</a>.</p>
<p>On to the proofy bit!</p>
<h1 id="a-short-aside-on-mutability">A short aside on mutability</h1>
<p>The algorithm works on singly linked lists implemented using C++
pointers. Working with mutable, dynamically allocated data structures
complicates the proof significantly. Since I don’t want to go down the
<a href="https://dl.acm.org/doi/pdf/10.1145/3211968">Separation
Logic</a> rabbit hole we’ll make the following simplification: we treat
the linked lists as <em>finite sequences</em>.</p>
<p>It turns out Dafny uses a similar approach with an extra twist to
ensure the lists aren’t circular.</p>
<h1 id="the-linked-list-data-structure">The linked list data
structure</h1>
<p>The <code>Node</code> class is what you’d expect–it has a value and a
next pointer–with added machinery to aid proofs and a convenience method
for constructing lists which I’ve omitted. I’ll get to them shortly.</p>
<pre class="dafny"><code>class Node&lt;T(0)&gt;
{
  var value: T;
  var next: Node?&lt;T&gt;;

  // Proof aides

  static method Cons(x: T, xs: Node?&lt;T&gt;) returns (n: Node&lt;T&gt;)
    // Pre- and postcondition
  {
    // Implementation
  }
}</code></pre>
<p>If you’re wondering about the <code>(0)</code> bit after the type
parameter, that tells Dafny that whatever type we supply it must be
“default constructible” in C++ parlance.</p>
<p>We’ll get to the implementation of <code>Cons</code> in a bit, but
first let’s look at how Dafny deals with mutable linked lists. Since
linked lists are a recursive data structures our algorithms will have to
use either loops or recursion. In either case Dafny will have trouble
proving that the process terminates because we might be dealing with a
circular list. The basic approach to solving this difficulty is to keep
track of what nodes go where, and prove that a node can’t appear in the
list starting at its <code>next</code> pointer. The idiom in Dafny <a
href="https://dafny.org/dafny/DafnyRef/DafnyRef#11-dafny-example">seems
to be</a> to define a <em>predicate</em> called <code>Valid</code>
together with some <em>ghost</em> fields to track the proof state for
the linked list. Unlike methods and regular fields, predicates and ghost
fields are only used for verification<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<pre class="dafny"><code>  // Proof aides

  ghost var Elems: seq&lt;T&gt;;
  ghost var Repr: set&lt;Node&lt;T&gt;&gt;;

  predicate Valid()
    reads this, Repr
  {
    this in Repr &amp;&amp;
    |Elems| &gt; 0 &amp;&amp; Elems[0] == value &amp;&amp;
    (next == null ==&gt; |Elems| == 1) &amp;&amp;
    (next != null ==&gt;
      next in Repr &amp;&amp; next.Repr &lt;= Repr &amp;&amp; this !in next.Repr &amp;&amp;
      next.Valid() &amp;&amp; next.Elems == Elems[1..])
  }</code></pre>
<p><code>Elems</code> tracks the elements of the list. <code>Repr</code>
is more interesting, and it’s the key ingredient for allowing us to work
with linked lists. It’s a set tracking the nodes in the representation
of the list<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>. <code>Valid</code> uses it to check
that a node doesn’t appear in the list that starts from it, that is,
that it’s not circular. It turns out this is enough to allow Dafny to
work out termination for loops involving linked lists made of
<code>Node</code>s.</p>
<p>Now we can finally look at <code>Cons</code> which is pretty much
what you’d expect plus some proof state bookkeeping.</p>
<pre class="dafny"><code>  static method Cons(x: T, xs: Node?&lt;T&gt;) returns (n: Node&lt;T&gt;)
    requires xs == null || xs.Valid()
    ensures n.Valid()
    ensures if xs == null then n.Elems == [x] else n.Elems == [x] + xs.Elems
  {
    n := new Node;
    n.value, n.next := x, xs;
    if xs == null
    {
      n.Elems := [x];
      n.Repr := {n};
    } else {
      n.Elems := [x] + xs.Elems;
      n.Repr := {n} + xs.Repr;
    }
  }</code></pre>
<p>The precondition–introduced by <code>requires</code>–asks for a valid
node, and the postconditions–introduced by <code>ensures</code>–make
sure we leave the node in a valid state and that we’ve actually
prepended <code>x</code> to <code>xs</code>. The actual logic is the
first two lines. The <code>if</code> keeps the proof state valid.</p>
<h1 id="the-intersection-algorithm">The intersection algorithm</h1>
<p>We’re now have all the ingredients to write and prove the
intersection algorithm. The algorithm is similar to the one last time,
but I’ve had to make a few adjustments to make Dafny happy.</p>
<p>Let’s start by looking at the pre- and post conditions.</p>
<pre class="dafny"><code>method Intersects&lt;T(0)&gt;(a: Node?&lt;T&gt;, b: Node?&lt;T&gt;) returns (r: Node?&lt;T&gt;)
  requires a == null || a.Valid()
  requires b == null || b.Valid()
  ensures a == null || b == null ==&gt; r == null
  ensures r == null || (r in ListRepr(a) &amp;&amp; r in ListRepr(b))
{
  // &quot;Synchronise&quot; lists heads

  // Find the intersection point
}</code></pre>
<p>The preconditions are fairly light, we want the lists to be valid. As
mentioned above, this is key allowing Dafny to derive termination proofs
for the inner loops.</p>
<p>By the way, the <code>?</code> after <code>Node</code> in the type
signatures means it’s a “nullable” type. That means we have to deal with
<code>null</code> all over the place, but it models the original
algorithm better.</p>
<p>The postconditions say if either of the inputs is <code>null</code>
so will be the reult–fair enough, if any or both lists are empty they
have no intersection point–and that if the result is not
<code>null</code>–we found an intersection point–it’s present in both
lists.</p>
<p>Now these may sound like reasonable postconditions, but the last one
is not as strong as it cold be. It would be better if we made sure the
intersection point is the <em>first</em> common node between the two
instead of a common node. It looks like it would take a bit more work to
convince Dafny to verify that postcondition so I decided to publish the
proof as it is. I might revisit this at some point in the future.</p>
<p>OK, it’s time to have a look at the first part of the algorithm where
we “synchronise” the list heads so we can then walk them in
lockstep.</p>
<pre class="dafny"><code>  // &quot;Synchronise&quot; lists heads

  var m: nat := Length(a);
  var n: nat := Length(b);
  var pa, pb := a, b;
  
  if m &gt; n
  {
    while m &gt; n
      invariant pa != null ==&gt; pa.Valid()
      invariant m == ElemCount(pa) &amp;&amp; n == ElemCount(pb)
      invariant m &gt;= n
      decreases ListRepr(pa)
    {
      pa := pa.next;
      m := m - 1;
    }

    assert m &lt;= n;
    assert pa != null ==&gt; pa in ListRepr(a);
    assert pb != null ==&gt; pb in ListRepr(b);
  } else if n &gt; m {
    while n &gt; m
      invariant pb != null ==&gt; pb.Valid()
      invariant m == ElemCount(pa) &amp;&amp; n == ElemCount(pb)
      invariant n &gt;= m
      decreases ListRepr(pb)
    {
      pb := pb.next;
      n := n - 1;
    }

    assert n &lt;= m;
    assert pa != null ==&gt; pa in ListRepr(a);
    assert pb != null ==&gt; pb in ListRepr(b);
  }</code></pre>
<p>We keep the lengths of the lists in <code>m</code> and <code>n</code>
respectively, and use <code>pa</code> and <code>pb</code> to iterate
over them. I won’t show the definition of <code>Length</code> here, but
it’s what you’d expect.</p>
<p>I’ve had to add an explicit <code>if</code> around the two loops to
convince Dafny that the loop invariants hold on entry in the loops. To
be honest I think that’s reasonable, and it makes the algorithm easier
to understand at the cost of an extra check.</p>
<p>The loop invariants make sure <code>m</code> and <code>n</code> stay
in sync with the lengths of the lists as <code>pa</code> and
<code>pb</code>. The important point here is that call to
<code>Valid</code> together with the
<code>decreases ListRepr(...)</code> clause allow Dafny to prove that
the list makes progress at each step, and eventually terminates. I’m
don’t know about you but I find this pretty cool.</p>
<p>The assertions are not strictly necessary, but I like to have sanity
checks thrown in.</p>
<p>On to the main loop. Before we enter the loop we have <span
class="math inline"><em>m</em> ≤ <em>n</em> ∧ <em>n</em> ≤ <em>m</em></span>.
Therefore <span class="math inline"><em>m</em> = <em>n</em></span>.
They’re also both in sync with length of the lists starting in
<code>pa</code> and <code>pb</code>.</p>
<pre class="dafny"><code>  // Find the intersection point

  assert m == ElemCount(pa) &amp;&amp; n == ElemCount(pb) &amp;&amp; m == n;
  assert pa != null ==&gt; pa in ListRepr(a);
  assert pb != null ==&gt; pb in ListRepr(b);

  while pa != pb
    invariant pa != null ==&gt; pa.Valid()
    invariant pb != null ==&gt; pb.Valid()
    invariant m == ElemCount(pa) &amp;&amp; n == ElemCount(pb) &amp;&amp; m == n
    decreases ListRepr(pa), ListRepr(pb)
  {
    pa := pa.next;
    pb := pb.next;
    m := m - 1;
    n := n - 1;
  }

  assert pa == pb;

  r := pa;</code></pre>
<p>The loop invariants make sure that <code>m</code> and <code>n</code>
stay in sync with the lists as well as with each other. This is why we
don’t have to explicitly check <code>pa</code> and <code>pb</code> for
<code>null</code> in the loop test.</p>
<p>And with that we’re done. I’m still not 100% happy with the
postcondition on the algorithm. I think I would come up with a stronger
postcondition if I kept track of the pointers as sequences instead of
sets, like in the case of <code>Elems</code>, and check that there’s no
earlier node that the sequences have in common before the result.
Anyway, this post is long enough as it is.</p>
<p>I’ve been meaning to play with theorem proving for a while, and this
was a nice excuse to do so. It was a mostly enjoyable exercise, and
Dafny seems like a nice language to start exploring the field.</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In logic expressions the operators
have the same meaning as in C. <code>|...|</code> stands for the length
of a collection of things, and <code>==&gt;</code> for logical
implication.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Actually each node has its own set
that is a subset of the one in the node pointing to it. Kind of like
Russian nesting dolls.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sat, 02 Jul 2022 17:00:00 +0100</pubDate>
</item>
<item>
<title>Determining the intersection point of two lists in O(1) space</title>
<link>https://muscar.eu/posts/linked-list-intersection.html</link>
<description>Determining the intersection point of two lists in O(1) space</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">Determining the intersection point of two lists in
O(1) space</h1>
<p class="author">Alex Muscar</p>
<p class="date">May 21, 2022</p>
</header>
<p><strong>May 24, 2022:</strong> <a
href="https://blog.dend.ro/">Laurențiu</a> pointed out an error in the
original version of the C++ implementation. The last loop was comparing
the node values instead of the node identities. I’ve updated the
implementation accordingly.</p>
<h1 id="problem-statement">Problem statement</h1>
<p>A while back <a href="https://blog.dend.ro/">a friend</a> shared an
interesting problem with me<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a>: given the heads of two
singly-linked lists, it asks for an algorithm to find the node at which
they intersect. We can assume the input lists don’t have cycles. The
linked lists must retain their structure after the algorithm is
finished.</p>
<p>One obvious solution is to store the first list’s nodes in a set or
similar data structure and check if any of the nodes in the second list
are present in it.</p>
<p>To make things more interesting my friend also asked if this can be
done in constant space.</p>
<h1 id="a-constant-space-solution">A constant space solution</h1>
<p>If the lists were the same length this would be easy to solve in
constant space: just walk over the two lists at the same time and
compare the elements. Since our lists can be any length we can’t use
this approach.</p>
<p>What we do know is that our lists don’t have loops<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.
Can we can take advantage of this observation in any way? Since the
lists don’t have loops they have an end. What if we walked the lists
backwards comparing each element? That would work, but walking the lists
backwards is awkward because they are singly-linked. The constraint on
space rules out any additional data structures where we could store info
about the reverse lists. If only we had doubly linked lists.</p>
<p>Hm, maybe there’s a way forward: it’s not a doubly-linked list we
really want, but the back pointers. What if we traversed each list
reversing pointers along the way? We’d be left with two singly linked
lists that we can then traverse to compare elements. Looks like we have
a solution.</p>
<p>But the constraints ask for the structure of the lists to be left
unchanged after the algorithm finishes. So we’d have to walk the lists
again reversing pointers to their original direction. This works, but
it’s getting complicated. Not to mention that we have to traverse each
list 3 times. Can we come up with a simpler solution?</p>
<p>Why did we want to start at the end of the lists? Because the lists
have different lengths so we don’t know how many nodes to skip from each
until they get “in sync”, and we can start comparing nodes.</p>
<p>There’s an assumption we’re making here–and I think the original
problem makes the same assumption implicitly. Namely, that the two
lists, once they intersect, have the same elements. That’s an important
assumption, and it’s what allows the approach outlined above to work. If
the lists just intersected in one element, and then went their separate
ways we’d face the same problem as when we wanted to start looking from
the beginning of the lists. Keep in mind that I’m making this assumption
moving forward.</p>
<p>Going back to walking the lists in reverse, we can look at it in a
slightly different light: we’re walking a list that branches into two
lists at some element. That’s the element we want to find. We don’t care
about the nodes that come after. That’s a useful insight.</p>
<p>Our initial problem was that we didn’t know when the lists would get
in sync so we can start comparing elements. But using our insight, it
seems safe to just skip elements from the lists until each has an equal
number of elements, that is, until we’re at the same distance from the
split point on both branches. Then we can just compare the elements, and
we’re done. Note that this approach still works when the two lists don’t
intersect (why?).</p>
<p>Given two pointers <span class="math inline"><em>A</em></span> and
<span class="math inline"><em>B</em></span> to singly-linked lists, the
process we described can be implemented by the following algorithm:</p>
<ol type="1">
<li>[Determine list lengths.] Set <span
class="math inline"><em>M</em> ← <em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>A</em>)</span>,
and <span
class="math inline"><em>N</em> ← <em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em>(<em>B</em>)</span>.</li>
<li>[Sync A’s starting point with B.] If <span
class="math inline"><em>M</em> &gt; <em>N</em></span>, then set <span
class="math inline"><em>A</em> ← <em>n</em><em>e</em><em>x</em><em>t</em>(<em>A</em>)</span>,
<span class="math inline"><em>M</em> ← <em>M</em> − 1</span> and repeat
this step.</li>
<li>[Sync B’s starting point with A.] If <span
class="math inline"><em>N</em> &gt; <em>M</em></span>, then set <span
class="math inline"><em>B</em> ← <em>n</em><em>e</em><em>x</em><em>t</em>(<em>B</em>)</span>,
<span class="math inline"><em>N</em> ← <em>N</em> − 1</span> and repeat
this step.</li>
<li>[Search for first common node in lock-step] If <span
class="math inline"><em>A</em> ≠ <em>N</em><em>U</em><em>L</em><em>L</em> ∧ <em>B</em> ≠ <em>N</em><em>U</em><em>L</em><em>L</em> ∧ <em>A</em> ≠ <em>B</em></span>
set <span
class="math inline"><em>A</em> ← <em>n</em><em>e</em><em>x</em><em>t</em>(<em>A</em>)</span>,
<span
class="math inline"><em>B</em> ← <em>n</em><em>e</em><em>x</em><em>t</em>(<em>B</em>)</span>
and repeat this step.</li>
<li>[Done.] Return <span class="math inline"><em>A</em></span>.</li>
</ol>
<p>(Why does it just work to return <span
class="math inline"><em>A</em></span>?)</p>
<p>It’s finally time to write some code. Since the focus is on the
intersection point algorithm we’ll define the simplest <code>node</code>
structure we can work with:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> node</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    T value<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    node<span class="op">*</span> next<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Yes, it uses raw pointers which goes against modern C++ best
practices. This is not production code.</p>
<p>Determining the length of a list is a straightforward task:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> length<span class="op">(</span>node<span class="op">&lt;</span>T<span class="op">&gt;*</span> a<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>a <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        n<span class="op">++;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With the boilerplate out of the way, the algorithm can be implemented
as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>node<span class="op">&lt;</span>T<span class="op">&gt;*</span> intersection_point<span class="op">(</span>node<span class="op">&lt;</span>T<span class="op">&gt;*</span> a<span class="op">,</span> node<span class="op">&lt;</span>T<span class="op">&gt;*</span> b<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> m <span class="op">=</span> length<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> n <span class="op">=</span> length<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>m <span class="op">&gt;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        m<span class="op">--;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>n <span class="op">&gt;</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> b<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        n<span class="op">--;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>a <span class="op">!=</span> <span class="kw">nullptr</span> <span class="op">&amp;&amp;</span> b <span class="op">!=</span> <span class="kw">nullptr</span> <span class="op">&amp;&amp;</span> a <span class="op">!=</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> a<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> b<span class="op">-&gt;</span>next<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>A previous version of the post linked
to the problem on a competitive coding site. Since then I’ve removed the
link.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>There is another implicit assumption
that the lists are finite. Since computers have a limited amount of
memory this might sound pedantic, but it’s going to be important in the
next post.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sat, 21 May 2022 18:00:00 +0100</pubDate>
</item>
<item>
<title>My blog workflow</title>
<link>https://muscar.eu/posts/my-blog-workflow.html</link>
<description>My blog workflow</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">My blog workflow</h1>
<p class="author">Alex Muscar</p>
<p class="date">February 6, 2023</p>
</header>
<p>I like to keep things simple. I will use shell scripts and standard
Unix tools whenever I can get away with it.</p>
<h1 id="the-publish-pipeline">The publish “pipeline”</h1>
<p>I use <a href="https://www.vim.org/">Vim</a> to write my blog
posts.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> I currently use <a
href="https://pandoc.org/">Pandoc</a> to convert my posts to HTML, so
the source files are in Pandoc’s flavour of Markdown. Since I don’t use
most of Pandoc’s features, I’m thinking of migrating to somthing more
lightweight like <a
href="https://kristaps.bsd.lv/lowdown/">Lowdown</a>.</p>
<p>Pandoc accepts metadata in its Markdown input. The metadata section
is delimited by <code>---</code> marker lines. For example, the metadata
block for this post looks like:</p>
<pre><code>---
title: My blog workflow
author: Alex Muscar
description: How I publish this blog
date: February 6, 2023
publishDate: Mon, 06 Feb 2023 17:41:20 +0000
---</code></pre>
<p>I don’t particularly enjoy writing RFC822 dates by hand, so I have a
little script that does it for me. I just read its output in Vim using
<code>:r!</code>.<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> And for uniformity–definitely not
because I’m lazy–the script also outputs a more readable date for
Pandoc.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="va">$1</span> <span class="kw">in</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ss">rfc822</span><span class="kw">)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">date</span> <span class="st">&#39;+%a, %d %b %Y %H:%M:%S %z&#39;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">;;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ss">post</span><span class="kw">)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">date</span> <span class="st">&#39;+%B %d, %Y&#39;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">;;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="pp">*</span><span class="kw">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">date</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="cf">esac</span></span></code></pre></div>
<p>The build script uses the <code>publishDate</code> field to decide
which posts are published. Drafts don’t have a publish date.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="va">FILES</span><span class="op">=</span><span class="va">$(</span><span class="fu">grep</span> <span class="at">-Fl</span> publishDate posts/<span class="pp">*</span>.md<span class="va">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="va">FILES</span><span class="op">=</span><span class="st">&quot;</span><span class="va">$FILES</span><span class="st"> posts/index.md&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="va">PANDOCOPTS</span><span class="op">=</span><span class="st">&#39;-f markdown+smart+tex_math_dollars+raw_tex -t html -s -H include/header.html -B include/header-link.html -V monofont:CascadiaCode,monospace&#39;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> f <span class="kw">in</span> <span class="va">$FILES</span><span class="kw">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">pandoc</span> <span class="va">$PANDOCOPTS</span> <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span> <span class="at">-o</span> out/<span class="va">$(</span><span class="fu">basename</span> <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span> .md<span class="va">)</span>.html</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span></span></code></pre></div>
<p>I also use the publish date to generate the RSS feed. That’s why it’s
RFC822.</p>
<p>I used to have a Go program that generated the RSS feed, but for my
needs I can get away with a shell script and two <a
href="https://www.goodreads.com/book/show/703101.The_AWK_Programming_Language">awk</a>
helpers. The shell script, <code>rssgen.sh</code>, is a glorified
template. It uses heredocs to generate the feed XML, and a few utilities
to fill in the post specific details.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> <span class="op">&lt;&lt; TPL</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;rss version=&quot;2.0&quot; xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot;&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;channel&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;title&gt;Alex&amp;#39;s website&lt;/title&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;link&gt;https://muscar.eu/&lt;/link&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;description&gt;I try to make computers do cool things. Sometimes I succeed.&lt;/description&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;managingEditor&gt;[email protected] (Alex Muscar)&lt;/managingEditor&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;pubDate&gt;</span><span class="va">$(</span><span class="ex">./date.sh</span> rfc822<span class="va">)</span><span class="st">&lt;/pubDate&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">TPL</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="fu">grep</span> <span class="at">-Frl</span> publishDate posts/<span class="pp">*</span>.md <span class="kw">|</span> <span class="fu">cut</span> <span class="at">-d.</span> <span class="at">-f1</span> <span class="kw">|</span> <span class="cf">while</span> <span class="bu">read</span> <span class="at">-r</span> <span class="va">f</span><span class="kw">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span> <span class="op">&lt;&lt;- TPL</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;item&gt;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;title&gt;</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=title <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span>.md<span class="va">)</span><span class="st">&lt;/title&gt;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;link&gt;https://muscar.eu/</span><span class="va">$f</span><span class="st">.html&lt;/link&gt;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;description&gt;</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=title <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span>.md<span class="va">)</span><span class="st">&lt;/description&gt;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;content:encoded&gt;&lt;![CDATA[</span><span class="va">$(</span><span class="ex">./body.awk</span> <span class="st">&quot;out/</span><span class="va">$(</span><span class="fu">basename</span> <span class="va">$f)</span><span class="st">.html&quot;</span><span class="va">)</span><span class="st">]]&gt;&lt;/content:encoded&gt;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;author&gt;</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=author <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span>.md<span class="va">)</span><span class="st">&lt;/author&gt;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;pubDate&gt;</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=publishDate <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span>.md<span class="va">)</span><span class="st">&lt;/pubDate&gt;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;/item&gt;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="st">    TPL</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="st">done</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="st">cat &lt;&lt; TPL</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;/channel&gt;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;/rss&gt;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="op">TPL</span></span></code></pre></div>
<p>The awk helpers are really simple. <code>meta.awk</code> extracts a
metadata field given its name.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode awk"><code class="sourceCode awk"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/awk -f</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">/</span><span class="ss">---</span><span class="ot">/</span> <span class="op">&amp;&amp;</span> ismeta <span class="op">{</span> <span class="cf">exit</span> <span class="op">}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">/</span><span class="ss">---</span><span class="ot">/</span> <span class="op">{</span> ismeta <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="bu">FS</span><span class="op">=</span><span class="st">&quot;: &quot;</span><span class="op">;</span> <span class="kw">next</span> <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>ismeta <span class="op">&amp;&amp;</span> <span class="dt">$1</span> <span class="op">==</span> field <span class="op">{</span> <span class="kw">print</span> <span class="dt">$2</span> <span class="op">}</span></span></code></pre></div>
<p><code>body.awk</code> extracts the body from the HTML version of the
post.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode awk"><code class="sourceCode awk"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/awk -f</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">/</span><span class="ss">&lt;</span><span class="ot">\</span><span class="sc">/</span><span class="ot">?</span><span class="ss">body&gt;</span><span class="ot">/</span> <span class="op">{</span> isbody <span class="op">=</span> <span class="op">!</span>isbody<span class="op">;</span> <span class="kw">next</span> <span class="op">}</span> isbody</span></code></pre></div>
<p>Both scripts use a common awk idiom for extracting multi-line
records.</p>
<p>Similarly to <code>rssgen.sh</code>, I have a script to generate the
index page automatically. Very imaginatively it’s called
<code>indexgen.sh</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/sh</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> <span class="op">&lt;&lt;TPL</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="st">---</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="st">title: Alex&#39;s website</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="st">---</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="st">Hey there! Welcome to my site.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="st">## Writing ([RSS feed](/feed.xml))</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">TPL</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="fu">grep</span> <span class="at">-Fl</span> publishDate posts/<span class="pp">*</span>.md <span class="kw">|</span> <span class="cf">while</span> <span class="bu">read</span> <span class="at">-r</span> <span class="va">f</span><span class="kw">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">title</span><span class="op">=</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=title <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span><span class="va">)</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="va">date</span><span class="op">=</span><span class="va">$(</span><span class="ex">./meta.awk</span> <span class="at">-v</span> field=date <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span><span class="va">)</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">printf</span> <span class="st">&quot;%s\0%s\0/%s\n&quot;</span> <span class="st">&quot;</span><span class="va">$date</span><span class="st">&quot;</span> <span class="st">&quot;</span><span class="va">$title</span><span class="st">&quot;</span> <span class="st">&quot;</span><span class="va">$(</span><span class="fu">basename</span> <span class="st">&quot;</span><span class="va">$f</span><span class="st">&quot;</span> .md<span class="va">)</span><span class="st">.html&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="cf">done</span> <span class="kw">|</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span> <span class="at">-k3.1,3.5r</span> <span class="at">-k1Mr</span> <span class="at">-k2nr</span> <span class="kw">|</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span> <span class="st">&#39;\0&#39;</span> <span class="st">&#39;$&#39;</span> <span class="kw">|</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="fu">awk</span> <span class="at">-F</span><span class="st">&#39;$&#39;</span> <span class="st">&#39;{ print &quot;**&quot; $1 &quot;**&lt;br/&gt;[&quot; $2 &quot;](&quot; $3 &quot;)\n&quot;}&#39;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> <span class="op">&lt;&lt;TPL</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="st">## Blogroll</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="st">[Laurențiu](https://blog.dend.ro)</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="st">[Andrei](https://www.andreinc.net/)</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="st">## About</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="st">I use [Vim](https://www.vim.org/) to edit the Markdown posts on computers</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="st">running [openbsd](https://www.openbsd.org/) and macOS. You can find my .vimrc</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="st">file &lt;a href=&quot;_vimrc&quot; type=&quot;text/plain&quot;&gt;here&lt;/a&gt; if you&#39;re curious.</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="st">I use [Pandoc](https://pandoc.org/) to convert the posts to HTML.</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="st">The publishing &quot;pipeline&quot; is a [collection of shell scripts](my-blog-workflow.html) that I run manually.</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="st">The monospaced font is [Cascadia Code](https://github.com/microsoft/cascadia-code).</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="st">The site is hosted on [openbsd.amsterdam](https://openbsd.amsterdam/).</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="op">TPL</span></span></code></pre></div>
<p><code>indexgen.sh</code> is definitely pushing it. Note the
<code>\0</code> field delimiter for the lines printed in the
<code>while</code> loop, and the complicated <code>sort</code> keys.<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></p>
<p>And to tie it all up, I have a Makefile:</p>
<pre class="make"><code>gen:
    ./build.sh
    ./rssgen.sh &gt; out/feed.xml

upload:
    ./upload.sh

clean:
    rm -f out/*.{html,xml}</code></pre>
<p>Publishing my blog is then just <code>make clean gen upload</code>.<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></p>
<p>I use <a href="https://www.shellcheck.net/">shellcheck</a> to check
the scripts.</p>
<h1 id="conclusion">Conclusion</h1>
<p>You can publish a blog using minimal dependencies. You don’t even
need a static site generator. You can get away with shell scripts and
standard Unix tools.</p>
<p>There are still a few shortcomings to this approach.</p>
<p>First, I don’t have a post tagging system yet, or an archive. I think
that’d be relatively straightforward to implement though, and it’s on my
TODO list.</p>
<p><del>Second, I have to manually update the list of posts in the index
file. This can also be automated, but it’s not a massive pain point
right now.</del></p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>You can find my .vimrc file
<a href="_vimrc" type="text/plain">here</a> if you’re curious.<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>I actually have some key bindings to
do that for me :^)<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>I’m not very happy with using
<code>$</code> as a delimiter for the fields I pass to awk, but awk
can’t handle <code>\0</code> as a field delimiter in a portable way.<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>upload.sh</code> is just a
wrapper around <code>scp</code>.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Mon, 06 Feb 2023 17:41:20 +0000</pubDate>
</item>
<item>
<title>On self-modifying executables in Go</title>
<link>https://muscar.eu/posts/self-modify.html</link>
<description>On self-modifying executables in Go</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">On self-modifying executables in Go</h1>
<p class="author">Alex Muscar</p>
<p class="date">January 30, 2022</p>
</header>
<p>Recently, a friend <a
href="https://blog.dend.ro/self-modifying-rust/">wrote</a> about
self-modifying executables in Rust. I was curious if I can do the same
thing in Go. The short answer is “yes”. If you’re curious how I did it,
read on.</p>
<h2 id="general-approach">General approach</h2>
<p>We start with a simple program, and develop the patching code in the
rest of this writeup:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>  <span class="op">(</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> CNT <span class="op">=</span> <span class="dv">0xCAFEBABE</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span>CNT<span class="op">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Patch the binary to increment CNT</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We’ll investigate the ELF file form the command line, so I
initialised <code>CNT</code> to an easy to find value.</p>
<p>The Rust program uses the <code>link_section</code> attribute put the
counter variable in a dedicated section. That’s quite neat, but we can’t
do that in Go. While having the variable live in a dedicated section
makes it easier to find it, it’s not essential. We can use the
executable’s <em>symbol table</em> instead.</p>
<p>The <code>strings</code> program dumps the string in an executable.
It’s a good starting point for analysing the binary:</p>
<pre class="shell"><code>$ strings self-modify | grep CNT
    stack=[cgocheckdeadlockmain.CNTno anodepollDescrunnablerwmutexRrwmutexWscavengetraceBufunknown( (forced) -&gt; node= B exp.)  B work ( blocked= in use)
main.CNT
runtime.x86HasPOPCNT</code></pre>
<p>OK, we’re looking for the symbol named <code>main.CNT</code>.
<code>readelf</code> is a handy tool for analysing ELF binaries. We can
list the entries in our executable’s symbol table, and have a look at
<code>main.CNT</code>:</p>
<pre class="shell"><code>$ readelf -s self-modify

   Num:    Value          Size Type    Bind   Vis      Ndx Name
  
  ...
  
  1706: 00000000005472a8     8 OBJECT  GLOBAL DEFAULT    9 main.CNT

  ...</code></pre>
<p>The entry holds all the details we need to find <code>CNT</code> in
the binary: the section index (<code>Ndx</code>), the variable size, and
the location for its storage (<code>Value</code>). One thing to keep in
mind is that the location is not an offset in the executable file, but a
<em>virtual address</em>.</p>
<p>Let’s have a look at section 9:</p>
<pre class="shell"><code>$ readelf --sections self-modify
There are 23 section headers, starting at offset 0x1c8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align

  ...

  [ 9] .noptrdata        PROGBITS         00000000005471c0  001471c0
       0000000000010a60  0000000000000000  WA       0     0     32</code></pre>
<p>The object is placed in the <code>.noptrdata</code> section which is
a Go specific section. But we’re not really bothered by that. What we
care about it the <code>Address</code> field. That’s the virtual address
of the section. Using the symbol table entry’s virtual address and the
section virtual address we can work out our object’s offset in the
section:</p>
<pre class="shell"><code>$ python3 -c &#39;print(0x00000000005472a8 - 0x00000000005471c0)&#39;
232</code></pre>
<p>The final step is to find the object’s physical location. This is
where we use the section offset. We add the object offset to the section
offset to find out where the storage for our counter is in the
executable. Let’s check our logic:</p>
<pre class="shell"><code>$ python3 -c &#39;print(0x001471c0 + 232)&#39;
1340072
$ hexdump -s 1340072 -n 8 self-modify
01472a8 babe cafe 0000 0000 </code></pre>
<p>Cool, it works. Now we can write some code to do the patching.</p>
<h2 id="the-code">The code</h2>
<p>The full program is just the steps we ran above in the shell
translated to Go (plus error handling, more on that later). Go’s
standard library comes with a <a
href="https://pkg.go.dev/debug/elf">debug/elf</a> module which makes
reading ELF files almost as convenient as using
<code>readelf</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">package</span> main</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="op">(</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;bytes&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;debug/elf&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;fmt&quot;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;io&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;log&quot;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;os&quot;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> CNT <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> entry <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    value<span class="op">,</span> off <span class="dt">uint64</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> getEntry<span class="op">(</span>f <span class="op">*</span>elf<span class="op">.</span>File<span class="op">,</span> name <span class="dt">string</span><span class="op">)</span> <span class="op">(*</span>entry<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    syms<span class="op">,</span> err <span class="op">:=</span> f<span class="op">.</span>Symbols<span class="op">()</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ot">nil</span><span class="op">,</span> err</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _<span class="op">,</span> s <span class="op">:=</span> <span class="kw">range</span> syms <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s<span class="op">.</span>Name <span class="op">==</span> name <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            sect <span class="op">:=</span> f<span class="op">.</span>Sections<span class="op">[</span>s<span class="op">.</span>Section<span class="op">]</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            bs<span class="op">,</span> _ <span class="op">:=</span> sect<span class="op">.</span>Data<span class="op">()</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            varOff <span class="op">:=</span> s<span class="op">.</span>Value <span class="op">-</span> sect<span class="op">.</span>Addr</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">&amp;</span>entry<span class="op">{</span>f<span class="op">.</span>ByteOrder<span class="op">.</span>Uint64<span class="op">(</span>bs<span class="op">[</span>varOff <span class="op">:</span> varOff<span class="op">+</span>s<span class="op">.</span>Size<span class="op">]),</span> sect<span class="op">.</span>Offset <span class="op">+</span> varOff<span class="op">},</span> <span class="ot">nil</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span><span class="op">,</span> fmt<span class="op">.</span>Errorf<span class="op">(</span><span class="st">&quot;can&#39;t find symbol &#39;%s&#39;&quot;</span><span class="op">,</span> name<span class="op">)</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span>CNT<span class="op">)</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Patch the binary to increment CNT</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    exeName <span class="op">:=</span> os<span class="op">.</span>Args<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    tmpName <span class="op">:=</span> exeName <span class="op">+</span> <span class="st">&quot;.tmp&quot;</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    f<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>Open<span class="op">(</span>exeName<span class="op">)</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;can&#39;t open file &#39;%s&#39;: %e&quot;</span><span class="op">,</span> exeName<span class="op">,</span> err<span class="op">)</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> f<span class="op">.</span>Close<span class="op">()</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    data<span class="op">,</span> _ <span class="op">:=</span> io<span class="op">.</span>ReadAll<span class="op">(</span>f<span class="op">)</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    elfFile<span class="op">,</span> err <span class="op">:=</span> elf<span class="op">.</span>NewFile<span class="op">(</span>bytes<span class="op">.</span>NewReader<span class="op">(</span>data<span class="op">))</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;can&#39;t read ELF file: %e&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>    entry<span class="op">,</span> err <span class="op">:=</span> getEntry<span class="op">(</span>elfFile<span class="op">,</span> <span class="st">&quot;main.CNT&quot;</span><span class="op">)</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;can&#39;t find counter object in ELF file: %e&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    elfFile<span class="op">.</span>ByteOrder<span class="op">.</span>PutUint64<span class="op">(</span>data<span class="op">[</span>entry<span class="op">.</span>off<span class="op">:],</span> entry<span class="op">.</span>value<span class="op">+</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    fi<span class="op">,</span> err <span class="op">:=</span> f<span class="op">.</span>Stat<span class="op">()</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;can&#39;t get file mode for &#39;%s&#39;: %e&quot;</span><span class="op">,</span> os<span class="op">.</span>Args<span class="op">[</span><span class="dv">0</span><span class="op">],</span> err<span class="op">)</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> os<span class="op">.</span>WriteFile<span class="op">(</span>tmpName<span class="op">,</span> data<span class="op">,</span> fi<span class="op">.</span>Mode<span class="op">());</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalf<span class="op">(</span><span class="st">&quot;can&#39;t write file &#39;%s&#39;: %e&quot;</span><span class="op">,</span> tmpName<span class="op">,</span> err<span class="op">)</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> os<span class="op">.</span>Rename<span class="op">(</span>tmpName<span class="op">,</span> os<span class="op">.</span>Args<span class="op">[</span><span class="dv">0</span><span class="op">]);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>        log<span class="op">.</span>Fatalln<span class="op">(</span><span class="st">&quot;can&#39;t rename temporary file&quot;</span><span class="op">,</span> err<span class="op">)</span></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="caveats">Caveats</h2>
<p>The most obvious caveat is that this only works for ELF files on
Linux (it might work on other operating systems using ELF, but I haven’t
tested it).</p>
<p>The code also assumes that the compiler always reserves storage for
the variable in the object file. At the time of writing, under go 1.17,
that’s the case. And, since this is an exported variable, the compiler
won’t inline it. <em>But</em> this is the only module. And the variable
is not used anywhere else. If in a later version the compiler starts
doing some clever cross module analysis it may well decide to inline the
value in the one place it’s used. Fun exercies: try changing the
<code>var</code> to a <code>const</code> and see what happens.</p>
<p>Why did we initialise <code>CNT</code> to <code>1</code> and not
<code>0</code>? If we did initialise it to <code>0</code> the compiler
would put it in the <code>.bss</code> which is treated specially by the
program loader. The executable only stores the length of the segment,
not the data. The loader allocates the data when it loads the program.
That means there’s nothing for us to patch.</p>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sun, 30 Jan 2022 17:00:00 +0000</pubDate>
</item>
<item>
<title>Beautiful Binary Search in D</title>
<link>https://muscar.eu/posts/shar-binary-search-meta.html</link>
<description>Beautiful Binary Search in D</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">Beautiful Binary Search in D</h1>
<p class="author">Alex Muscar</p>
<p class="date">February 18, 2023</p>
</header>
<p><strong>February 28, 2023:</strong> <span class="citation"
data-cites="tgehr">@tgehr</span> <a
href="https://old.reddit.com/r/d_language/comments/115k85f/beautiful_binary_search_in_d/ja8mr6y/">posted</a>
a zero-based version of the algorithm. They also pointed out that my
original code passed the static arrays by value. I’ve updated the code
in the post to use <code>ref</code> for the array parameters as well as
D’s exponentiation operator, <code>^^</code>. <span class="citation"
data-cites="tgehr">@tgehr</span>’s version also returns the first
postiion of the element if there are multiple instances, while the one
in this post returns the last one. Thanks for the suggestions!</p>
<p><strong>February 18, 2023:</strong> <span class="citation"
data-cites="schveiguy">@schveiguy</span> <a
href="https://old.reddit.com/r/d_language/comments/115k85f/beautiful_binary_search_in_d/j925wty/">pointed
out</a> that the initial approach to determining the static array size
was overly complicated. I’ve updated the code to incorporate their
suggestion. Thanks!</p>
<p>Recently, while I was reading <a
href="https://www.goodreads.com/book/show/128599.Writing_Efficient_Programs">“Writing
Efficient Programs”</a>, I came across a beautiful variation of binary
search and its implementation. In this post I’ll be using D’s
metaprogramming capabilities to implement a generic version of the
algorithm.</p>
<p>For the rest of the post I’m going to assume you’re familiar with
binary search, and its most common implementation–the bisection method
using two pointers.</p>
<h2 id="a-beautiful-algorithm">A beautiful algorithm</h2>
<p>There are many ways to implement a binary search. The most common is
probably using a “bisection search”, where we track the subintervals
using two pointers, one moving from left to right, the other from right
to left.</p>
<p>Another variant is the “uniform search”, where instead of using two
pointers, we use only a single pointer and a “rate of change”, i.e., the
start and the size of the subintervals. This is more subtle than
bisection search–which is not trivial by the way. In Knuth’s words:</p>
<blockquote>
<p>It is possible to do this, but only if extreme care is paid to the
details, […]. Simpler approaches are doomed to failure.</p>
</blockquote>
<p>On the other hand, uniform search has some advantages. One of them is
that the the rates of change can be precalculated, and stored in a side
table. If we get the rate of change calculation right–which is the
subtle part–the search algorithm is simpler than its cousin using two
pointers.</p>
<p>A variation of uniform search is Shar’s algorithm. It does away with
the side table, and uses power of two interval sizes.</p>
<p>It starts by comparing the the key we are looking for, <span
class="math inline"><em>K</em></span>, with <span
class="math inline"><em>K</em><sub><em>i</em></sub></span>, where <span
class="math inline"><em>i</em> = 2<sup><em>k</em></sup></span>, <span
class="math inline"><em>k</em> = ⌊<em>l</em><em>g</em><em>N</em>⌋</span>.
If <span
class="math inline"><em>K</em> &lt; <em>K</em><sub><em>i</em></sub></span>,
the interval sizes are <span
class="math inline">2<sup><em>k</em> − 1</sup></span>, <span
class="math inline">2<sup><em>k</em> − 2</sup></span>, <span
class="math inline">…</span>, <span class="math inline">1</span>, <span
class="math inline">0</span>. But if <span
class="math inline"><em>K</em> &gt; <em>K</em><sub><em>i</em></sub></span>,
we set <span
class="math inline"><em>i</em> = <em>N</em> − 2<sup><em>l</em></sup> + 1</span>,
where <span
class="math inline"><em>l</em> = ⌈<em>l</em><em>g</em>(<em>N</em>−2<sup><em>k</em></sup>+1)⌉</span>,
adjust the interval pointer, and the interval sizes are <span
class="math inline">2<sup><em>l</em> − 1</sup></span>, <span
class="math inline">2<sup><em>l</em> − 2</sup></span>, <span
class="math inline">…</span>, <span class="math inline">1</span>, <span
class="math inline">0</span>.</p>
<p>Shar’s algorithm determines the position of the entry with key <span
class="math inline"><em>K</em></span> bit by bit. Each test adds one
more bit. We need one more test, after we’ve determined all the bits, to
see if the entry is actually in the table.</p>
<h2 id="a-beautiful-implementation">A beautiful implementation</h2>
<p>Bentley provides a beautiful version of Shar’s algorithm in his book.
The code works for tables with 1000 elements. The code in the book is
written in Pascal, but transliterated to D it looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bsearch1000<span class="op">(</span><span class="fu">ref</span> <span class="dt">int</span><span class="op">[</span><span class="dv">1001</span><span class="op">]</span> xs<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">auto</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span><span class="dv">512</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">=</span> <span class="dv">1000</span> <span class="op">-</span> <span class="dv">512</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">256</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">256</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">128</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">128</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">64</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">64</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">32</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">32</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">16</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">16</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">8</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">8</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">4</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">4</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">2</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> <span class="op">{</span> i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> x<span class="op">)</span> <span class="kw">return</span> i<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There’s a few things going on here. First, the odd array size, 1001.
Pascal arrays are one-based. D follows in C’s footsteps with zero-based
arrays. We just ignore <code>xs[0]</code> in this case. This is a bug by
the way. Bentley acknowledges it, but he doesn’t provide a fix since he
considers it would detract from the exposition. We can fix it by setting
<code>i</code> to <code>1</code> initially, and making the necessary
code adjustments. This would complicate the code somewhat. Another way
to fix it by explicitly checking if <code>i</code> is <code>0</code> in
the last test.</p>
<p>Second, the code fully unrolls the search loop. This is only possible
because we know the size of the table beforehand. The code can be
adjusted for other table sizes as needed.</p>
<p>What makes this code beautiful is that it’s about as efficient as it
could be. It’s also uniform, and relatively easy to understand if you
know about Shar’s algorithm. It’s an almost word for word rendition of
the algorithm tailored for this particular table size.</p>
<h2 id="beautiful-metaprogramming">Beautiful metaprogramming</h2>
<p>Beautiful as it is, Bentley’s code is somewhat tedious to adjust to
other table sizes, and it’s easy to make mistakes while calculating the
initial value of <code>i</code>. The code is very repetitive and
uniform. This is a strong hint that we can automate writing it.</p>
<p>This is where D’s powerful metaprogramming capabilities come in. If
we can determine the size of the table at compile time, we could in
principle generate the code for the unrolled loop automatically.</p>
<p>As it turns out, we can determine if we’re dealing with a static
array, and get its size at compile time. Before I show you the code,
let’s break the problem down. The algorithm has three parts:</p>
<ol type="1">
<li><p>The initial test, comparing the search key <span
class="math inline"><em>K</em></span> with <span
class="math inline"><em>K</em><sub><em>i</em></sub></span> for <span
class="math inline"><em>i</em> = 2<sup><em>k</em></sup></span>, <span
class="math inline"><em>k</em> = ⌊<em>l</em><em>g</em><em>N</em>⌋</span>;</p></li>
<li><p>Determining successive bits of the candidate position by
iterating over powers of two; and</p></li>
<li><p>Checking if the we found the element we are looking for.</p></li>
</ol>
<p>Let’s start with the function signature:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> bsearch<span class="op">(</span>T<span class="op">,</span> <span class="bu">size_t</span> n<span class="op">)(</span><span class="fu">ref</span> T<span class="op">[</span>n<span class="op">]</span> xs<span class="op">,</span> T x<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span></code></pre></div>
<p>This is really neat. I didn’t expect the D compiler to deduce
<code>n</code>–C++ won’t– but it worked just fine. <code>T</code> is the
array element type, and <code>n</code> is the array’s length. This is a
static value, available at compile time.</p>
<p>Then we determine <span class="math inline"><em>k</em></span>, the
power of two where we start the search:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="wa">enum</span> k <span class="op">=</span> iflog2<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p><code>iflog2</code> stands for <i>i</i>nteger <i>f</i>loor
<i>log</i>arithm in base <em>2</em>. It’s a regular D function, but it
can be evaluated at compile time when called with a compile time value,
which is what we do here. Using an <code>enum</code> is very similar to
C++. Since our array is one-base we subtract one from its length.</p>
<p>The function parameters are the table <code>xs</code> and the key
<code>x</code> we are looking for.<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a> We’re passing
<code>xs</code> by <code>ref</code> so we don’t pass the whole array
when we call <code>basearch</code>.</p>
<p>The initial test is just the code rendition of the test in Shar’s
algorithm:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">auto</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span><span class="dv">2</span> <span class="op">^^</span> k<span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> p <span class="op">=</span> <span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">^^</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>We track the position of the candidate element in <code>p</code>.</p>
<p>Now for the fun bit, generating the power of two tests:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">static</span> <span class="kw">foreach_reverse</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">;</span> <span class="dv">0</span> .. k<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>xs<span class="op">[</span>p <span class="op">+</span> <span class="dv">2</span> <span class="op">^^</span> i<span class="op">]</span> <span class="op">&lt;=</span> x<span class="op">)</span> p <span class="op">+=</span> <span class="dv">2</span> <span class="op">^^</span> i<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>This code is remarkably short thanks to the problem’s regularity we
mentioned earlier, and to D’s powerful metaprogramming capabilities. A
<code>static foreach</code> is evaluated at compile time. And crucially,
it doesn’t introduce a new scope. The code inside is just “spliced” in
the code of the surrounding function. In effect, this snippet generates
a series of <code>if</code> statements equivalent to the one in
<code>bsearch1000</code>. We use <code>foreach_reverse</code> to iterate
over the the exponents <span class="math inline"><em>k</em></span> to
<span class="math inline">1</span>–the range <code>0 .. k</code> is
open, and we’re iterating over it in reverse. The choice of
<code>foreach_reverse</code> as a keyword is somewhat unfortunate. There
may be a cleaner way of achieving the same result, but I don’t use D
regularly, so this is what I came up with :^).</p>
<p>Once we’ve determined all the bits of the candidate element position
<code>p</code> all that’s left to do is to check if the element we’re
looking for is at that position.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>p <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> xs<span class="op">[</span>p<span class="op">]</span> <span class="op">==</span> x<span class="op">)</span> <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>And with this we’re done. If we check the code generated for
<code>bsearch1000</code> and <code>bsearch</code> on <a
href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1AB9U%2BlJL6yAngGVG6AMKpaAVxYM9DgDJ4GmADl3ACNMYhAAJgB2UgAHVAVCWwZnNw89eMSbAV9/IJZQ8OiLTCtshiECJmICVPdPLhKy5MrqglzAkLDImIUqmrr0xr62jvzCnoBKC1RXYmR2DjwWeJqAaj70ADp%2BYhYmAgBSAGYAIUONAEFl1YINgm39ggQtzFV4/0E8MRPzq5uSHdNlsni9iLMGPgjL8LtcVoD7ttiIZgJgYf94etgZtbOi4bdEVsCMjCAo8bC/HdgkpqsgEFwNIyIMRMFQ1pTDgBWU4MjRcLkAETWqgUpHZgmFk1hhyif0uFwAnExXER2WsTkKNOSNAq8GyICKuadOVwIoL1cdHBrJerZWrrbyNGsALRrE0RdURU5rflnW0C6U6vVrA1k7l4Q5eiKcgBs5pOVuOQtUk1t3rwnvOSbW0bjfplAauiuDoaNEa9poAHPHLdaU2n7V6HRFq/mooX5UH9Ybw5HTjHJDXE8nUzL05nrQPfv7A7ru2HTuXTsczZyhQm66O7Rm%2B9aV9OC7OSz3F32uHG1xbhzax42s0Lzwf20f52W%2B9XLxvs/Xbzum9nW29Q8iy7EMTyXQdP1rb8t3HXds0HNsO2LV9eyjIdNwbP97xzJ9kNA0s0J5DCYKwids19IDnxAhUXzAhcIyggNSJZAg5gYdltQVUolDWVj2LWLUzmlajO0uZVVT1WhUGACIIEpNYGFHJMTmwNZRD6eTBFTKhpJICBpNkiAlKlYSQPElVUDWalMFpBAIAAFTFRIAC9MGMO4lOZVk1gco0GHNEUxQcyURLlRUAHdiEIUoGAgSMIhGGxkDWapkQATwS0zwpoxh3DWABrC0hSkmS5I410uGy2copi2g4oSorrQSsUCuqmiJKs2JisE7VOzneijQ9LlsBGwqSJHNZuutYyXR9VNXQgYbOVGlbCtHL0fT6xUkrwFLdlsuljBZAA3MJeK0u4Iz9J0ti2dbZzHR6CJPabNuW1a1MY9doMmt6cI%2Bsbrpy2jRLoiBpuONSnUjOMIhjYUF1iGtmMm/jiA45GzP69GOKE8KwauTrrJpeZ7IcyZHKNQLRV80Ki1lGrooIWL4oiCJ0HS5gWD21LiAyrKuOJjjrQ0ghLtTEUtnoIxniFyzCp60qjIq%2Bb5dVSHNW2l6F0BtaComm1NZDVWqrmpb1RWsa2szLbsdnA6mCO07zswEMFOBwS1juh6aKev2daNf6c0tz7OKg6963%2B609a%2BrjgLElCQ0h6HPThhHXpRzDcamric/xkT8MuE7UDwdA1n2PwIClBmQY5blaMvTAFB6o0NDFRoczFCJu97rv%2B9XZiQdqln6ogGy7IgZvu8mdrE6DQQjV5flL0Ne2F6OblzXQNeQZ3hRpcYYBnh65ftYVXYQ2JncKOnG/r0dO/dy9WDnoVcCUbVAAqXD19onV95viYt/X%2BIME6RWZqzCeZNQwd0ZBoWeXER5QNJnSCA%2B84GMkQfbUSHBpi0E4JyXgngOBaFIKgTgQoFCzHmG7SMxweCkAIJoPB0wCogE5O3AhHBJDEJYeQzgvAFAgHbsw0heDSBwFgEgNAKw6BhHIJQWRsR5HhFoOgZAXBjDHHblgE6e1MAADU8CYAigAeViIwTgjCaC0BZsQYR49%2BHBD8NUdK1jeAuOYMQdKZjgjaEwNYDxpBZFsEEGYhgtB3HiNIFgfYRhxAxPwCyaweAzrCJiW8QJKpFhkMpKUfhtA8DBGRD45wWB%2BHEmWB46YukmDAAUMY0xFirHcF4PwQQIgxDsCkDIQQigVDqBiboRoBgjAgFMMYcwRTqTwGmKgWI5QMnOjMR6Z0sRTomIihqBQCBASMEwOgAAspgZ4GAFBCNKIE8o9hISDAaKQHwfhOgFG6I0TISQBD3IyAkT5DAxhdHCMMK5qSBCtAGC4eoehLDXJaP0dozzxhvIsPC75wx4UAteUC6Y1C5gLAkPgwhfCYkUI4GsdRKUuBbB0VsJ0EBcCEBIJ6BhkxeBiK0LPUg7DOH6E4Lw0gJCyGkqESIphLDOXcIiMSoVgixXiM5WdBxyQQCSCAA%3D">the
compiler explorer</a> we see that’s it’s virtually the same up. The D
compiler even inlined the compile time constants for us.</p>
<h2 id="bonus-making-it-truly-generic">Bonus: making it truly
generic</h2>
<p>One shortcoming of our solution is that it only works for static
arrays. It would be nice if we could detect that we’re dealing with a
dynamic array, and fall back to another algorithm.</p>
<p>You probably won’t be surprised to find out that we can–otherwise I
wouldn’t be writing this section :^).</p>
<p>The whole implementation is a bit anticlimatic really. We can just
use function overloading, and declare a version of <code>bsearch</code>
that takes a dynamic array parameter:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> bsearch<span class="op">(</span>T<span class="op">)(</span>T<span class="op">[]</span> xs<span class="op">,</span> T x<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    writeln<span class="op">(</span><span class="st">&quot;dynamic array: &quot;</span><span class="op">,</span> xs<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The compiler will choose the right overload based on the arguments we
call the function with.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Shar’s algorithm is a beautiful variation of binary search. If we
know the table size in advance we can write an efficient binary search
algorithm using it.</p>
<p>Bentley’s implementation is also beautiful because it squeezes every
bit of performance from the code. The code does no more than it should,
and there is a Zen kind of beauty to it.</p>
<p>D’s metaprogramming capabilities allowed us to take Bentley’s
beautiful code, and make it more general. We can generate the code for
any table size if we know it at compile time. Otherwise we fall back to
an algorithm that can deal with dynamic arrays. Andrei Alexandrescu
calls this technique <a
href="https://dconf.org/2017/talks/alexandrescu.html">“Design by
Introspection”</a>.</p>
<p>D is a fun language to program in. It shines for this kind of
problems, where you can make heavy use of metaprogramming. I haven’t
used any other language where this problem could be expressed as
cleanly, except maybe Common Lisp. I’d be curious to see a solution in
Rust (which has a strong macro system) and <del>Zig (which I read has
strong support for metaprogramming as well)</del>. Turns out someone <a
href="https://blog.deckc.hair/2023-02-22-smoking-hot-binary-search-in-zig.html">implemented</a>
the algorithm in Zig.</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In the example in this post the key
and the element are the same, they are integers.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sat, 18 Feb 2023 16:56:27 +0000</pubDate>
</item>
<item>
<title>Coroutines in SPARC assembly</title>
<link>https://muscar.eu/posts/sparc-coroutines.html</link>
<description>Coroutines in SPARC assembly</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">Coroutines in SPARC assembly</h1>
<p class="author">Alex Muscar</p>
<p class="date">April 29, 2023</p>
</header>
<p>A while back I picked up <a
href="https://www.goodreads.com/book/show/1881878.SPARC_Architecture_Assembly_Language_Programming_and_C">a
book</a> on the SPARC architecture from a second hand bookshop. To
justify the fiver I spent, I figured I might as well read it.<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> While reading the chapter on
subroutines, I realised that SPARC offers an elegant mechanism for
coroutine linking.</p>
<p>I won’t assume you’re familiar with SPARC. I’ll explain the relevant
details as I go along. It will help, though, if you’re at least somewhat
familiar with the assembly language of some other architecture.</p>
<p>You can find the code from this post <a
href="https://github.com/muscar/co-sparc">here</a>.</p>
<h2 id="on-coroutines">On coroutines</h2>
<p>Coroutines are not a new concept.<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> SIMULA is one of the
earliest languages to support.<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> In the past decade, more
and more languages have added support for coroutines of one sort or
another.</p>
<p>The term is somewhat overloaded, so let’s clarify it. A coroutine is
a generalization of a subroutine. A subroutine has <em>one</em> entry
point and <em>one</em> exit point. It’s called once, does its job, and
returns.</p>
<p>A coroutine has <em>many</em> entry and exit points. That is, its
execution can be <em>suspended</em> and <em>resumed</em>. Execution
resumes where it left off when the coroutine was suspended.</p>
<p>If a coroutine can choose who it <em>yields</em> to, it’s called
<em>symmetric</em>. If it can only yield to the most recent caller, then
it’s an <em>asymmetric</em> coroutine.</p>
<h2 id="the-implementation">The implementation</h2>
<p>The code targets Linux for 64-bit SPARC. There’s nothing 64-bit
specific about the implementation except the system call numbers. I used
the <code>as</code> and <code>ld</code> binaries that come with the
SPARC cross-build tools and QEMU To run the resulting binary.</p>
<h3 id="miscellany">Miscellany</h3>
<p>We begin by defining some useful constants and a macro for system
calls.</p>
<pre class="assembly"><code>.equ SYS_exit, 1
.equ SYS_write, 4

.equ STDOUT, 1

.macro syscall no
    mov \no, %g1
    t 0x6d
.endm</code></pre>
<p>System calls are implemented using <em>software traps</em> on SPARC.
The <code>t</code> instruction triggers a software trap. This works
similarly to interrupts on x86, i.e., the operating system sets up a
<em>trap table</em> that is then used to call the appropriate trap
handler.</p>
<p>Arguments for system calls go in the <em>global registers</em>,
starting with <code>%g1</code>.</p>
<h3 id="an-aside-on-sparc-registers">An aside on SPARC registers</h3>
<p>SPARC registers are grouped in four categories:</p>
<ul>
<li><p><em>Global registers:</em> <code>%g0</code>-<code>%g7</code>;
<code>%g0</code> is always zero when read, and writes to it are
ignored;</p></li>
<li><p><em>In registers:</em> <code>%i0</code>-<code>%i7</code>; used
for receiving parameters and returning results to callers;</p></li>
<li><p><em>Out registers:</em> <code>%o0</code>-<code>%o7</code>; used
for passing arguments and receiving results from callees; and</p></li>
<li><p><em>Local registers:</em> <code>%l0</code>-<code>%l7</code>; used
for temporary results and other bookkeeping for the current
routine.</p></li>
</ul>
<p>In addition to the above, SPARC also has a few special registers: the
stack pointer, <code>%sp</code>; the frame pointer, <code>%fp</code>;
and the link register, <code>%lr</code>.</p>
<p>On SPARC each function gets its own set of in, out and local
registers. This is implemented using a mechanism known as <a
href="https://icps.u-strasbg.fr/people/loechner/public_html/enseignement/SPARC/sparcstack.html">register
windows</a>.</p>
<p>When a function gets called, the out registers of the caller become
the in parameters of the callee. The local and out registers of the
callee are fresh.</p>
<h3 id="more-miscellany">More miscellany</h3>
<p>We’re going to use <code>%g2</code>, <code>%g3</code> and
<code>%g6</code> to keep the “state” of our coroutines. We have to tell
<code>as</code> we intend to use them as scratch registers.</p>
<pre class="assembly"><code>.register %g2, #scratch
.register %g3, #scratch
.register %g6, #scratch</code></pre>
<p>We’re not going to link to <code>libc</code> so our entry point is
called <code>_start</code>.</p>
<pre class="assembly"><code>    .section &quot;.text&quot;
    .align 4

    .global _start

_start:</code></pre>
<h3 id="function-prologues">Function prologues</h3>
<p>The first thing we do is to set up the stack frame for the main
coroutine. We’re not going to use any stack space, but on SPARC a
routine has to allocate at least enough space for some registers to be
spilled. That’s a consequence of SPARC’s register windows design.</p>
<p>Since there’s only so many transistors you can fit on a sliver of
silicone, SPARC doesn’t have infinitely many physical registers to give
dedicated local and out registers to every routine invocation. When the
processor runs out of physical registers, it spills the registers used
by one of the routines higher on the call stack.<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<pre class="assembly"><code>    save %sp, -64, %sp</code></pre>
<p><code>save</code> <em>adds</em> -64 bytes to <code>%sp</code>–like on
x86, the stack grows downwards on SPARC. It also performs the register
window shift that maps the out registers of the caller to the in
registers of the callee, and allocates new local and out registers. This
might lead to spilling, as mentioned above. That sure is a lot of work
for a RISC instruction.</p>
<h3 id="finally-coroutines">Finally coroutines</h3>
<p>Our program has three coroutines, imaginatively named
<code>_start</code>, <code>a</code> and <code>b</code>.
<code>_start</code> calls <code>a</code>, who prints <code>a1</code>,
yields to <code>b</code> who prints <code>b1</code> then yields to
<code>a</code>, who prints <code>a2</code> then yields back to
<code>b</code>; <code>b</code> then prints <code>b2</code>, returns to
<code>a</code>, who returns to <code>_start</code>. Finally,
<code>_start</code> just exits. Or in spiffy ASCII art (printed message
in brackets):</p>
<pre><code>_start -&gt; a (&quot;a1&quot;) -&gt; b (&quot;b1&quot;) -&gt; a (&quot;a2&quot;) -&gt; b (&quot;b2&quot;) -&gt; a -&gt; _start</code></pre>
<p>Remember we reserved <code>%g2</code> and <code>%g3</code> for the
coroutine states? Now we’re going to use them. We store the address of
the first instruction of <code>a</code> in <code>%g2</code> and the
address of the first instruction of <code>b</code> to <code>%g3</code>.
That’s why I put quotes around the word “state”–the coroutine state is
just its instruction pointer.</p>
<pre class="assembly"><code>    set a, %g2
    set b, %g3</code></pre>
<h3 id="yielding">Yielding</h3>
<p>With the state set up, we can start the coroutine dance by calling
<code>a</code>:</p>
<pre class="assembly"><code>    jmpl %g2, %g6
    add %g6, 8, %g6</code></pre>
<p>OK, let’s unpack this. <code>jmpl</code> jumps to the address in its
first register argument, and stores the address of the <em>program
counter</em> in the second register. In this case we’re jumping to the
address in <code>%g2</code>–that is <code>a</code>’s first instruction.
We store the return address in <code>%g6</code>, the main coroutine’s
state.</p>
<p>What’s up with the <code>add</code> after <code>jmpl</code>? That
instruction is called the branch instruction’s <em>delay slot</em>. I’m
not going to go into details about delay slots, but the gist is that, by
the time the CPU knows where to jump, it would have already started work
on the next instruction–the one in the delay slot. No sense in wasting
that work, so it will execute it anyway. The hope was that a
“sufficiently smart” compiler wold manage to put a useful instruction in
the delay slot, thus mitigating the cost of branches.</p>
<p>The instruction in the delay slot is executed <em>before</em> any of
the instructions in the target of the jump. We use it to adjust the
location where <code>_start</code> resumes its execution. Since
<code>jmpl</code> stores the value of the program counter in its second
register argument, we’d end up with <code>%g6</code> pointing at the
<code>jmpl</code> instruction itself. That would cause an infinite loop,
so we adjust <code>%g6</code> to resume execution after the
<code>jmpl</code>-<code>add</code> pair of instructions.<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>Raymond Chen covers MIPS <a
href="https://devblogs.microsoft.com/oldnewthing/20180411-00/?p=98485">delay</a>
<a
href="https://devblogs.microsoft.com/oldnewthing/20180412-00/?p=98495">slots</a>
in some detail.</p>
<p>The last thing <code>_start</code> does is to return to the operating
system.</p>
<pre class="assembly"><code>    syscall SYS_exit</code></pre>
<h3 id="the-other-coroutines">The other coroutines</h3>
<p>While <code>_start</code>.. er.. starts <code>a</code> by yielding to
it, <code>a</code> and <code>b</code> are more interesting since they
yield to each other. So let’s look at <code>a</code>.</p>
<p>We start with the <em>prologue</em> code, just like in
<code>_start</code>:</p>
<pre class="assembly"><code>a:
    save %sp, -64, %sp</code></pre>
<p>and then print the first message:</p>
<pre class="assembly"><code>    mov STDOUT, %o0
    set msg_a1, %o1
    mov (end_msg_a1-msg_a1), %o2
    syscall SYS_write</code></pre>
<p>The printing code is not really interesting. We just set the out
registers and call the <code>write</code> system call.</p>
<p>And it’s time to yield to <code>b</code> for the first time:</p>
<pre class="assembly"><code>    jmpl %g3, %g2
    add %g2, 8, %g2</code></pre>
<p>This should look familiar: we jump to
<code>%g3</code>–<code>b</code>’s instruction pointer–and store the
return address in <code>%g2</code>–<code>a</code>’s instruction
pointer.</p>
<p>When we resume <code>a</code>, we’ll start executing the code to
print the second message:</p>
<pre><code>    mov STDOUT, %o0
    set msg_a2, %o1
    mov (end_msg_a2-msg_a2), %o2
    syscall SYS_write</code></pre>
<p>Then we resume <code>b</code> again:</p>
<pre class="assembly"><code>    jmpl %g3, %g2
    add %g2, 8, %g2</code></pre>
<p>and finally return to <code>_start</code>:</p>
<pre><code>    mov 10, %i0
    jmpl %g6, %g0
    restore</code></pre>
<h3 id="function-epilogues">Function epilogues</h3>
<p>The return value of the coroutine is <code>10</code>. But why is it
in an input register? Shouldn’t the return value be an output? Remember
that <code>save</code> maps the caller’s outputs to the callee’s inputs?
Since the return value should be in the <code>%o0</code> register of the
caller that means we have to put it in <code>%i0</code> in the
callee.</p>
<p>Here we use <code>%g0</code> to ignore the instruction pointer saved
by <code>jmpl</code> since we’re done with the coroutine.</p>
<p>Finally, <code>restore</code> undoes what <code>save</code> did: it
restores the stack pointer and unmaps the registers. Since it’s in
<code>jmpl</code>’s delay slot, it’ll get executed before we actually
return from <code>a</code>.</p>
<h3 id="the-rest-of-the-code">The rest of the code</h3>
<p><code>b</code> is pretty much the same as <code>a</code>. The main
difference is that the last thing it does is to return <code>20</code>
to <code>a</code>. Note that <code>%g2</code> and <code>%g3</code> have
swapped places in the <code>jmpl</code> instructions.</p>
<pre class="assembly"><code>b:
    save %sp, -64, %sp

    mov STDOUT, %o0
    set msg_b1, %o1
    mov (end_msg_b1-msg_b1), %o2
    syscall SYS_write

    jmpl %g2, %g3
    add %g3, 8, %g3

    mov STDOUT, %o0
    set msg_b2, %o1
    mov (end_msg_b2-msg_b2), %o2
    syscall SYS_write

    mov 20, %i0
    jmpl %g2, %g0
    restore</code></pre>
<p>The messages we print live in the <code>.data</code> section:</p>
<pre class="assembly"><code>    .section &quot;.data&quot;
    .align 4

msg_a1: .ascii &quot;a1\n&quot;
end_msg_a1:

msg_a2: .ascii &quot;a2\n&quot;
end_msg_a2:

msg_b1: .ascii &quot;b1\n&quot;
end_msg_b1:

msg_b2: .ascii &quot;b2\n&quot;
end_msg_b2:</code></pre>
<p>And with this we’re done.</p>
<h3 id="quick-quiz">Quick quiz</h3>
<p>What is the exit code of the program? Why? Can you make it return the
value returned from either of the coroutines?</p>
<h2 id="conclusion">Conclusion</h2>
<p>I find the implementation of coroutines particularly neat on SPARC.
It only takes two instructions, one of which you is almost free–the
<code>add</code> in the delay slot. This is possible because SPARC’s
flexibility when it comes to storing return addresses on jumps. On x86
we’d have to use a relatively ugly hack to get the resume address.</p>
<p>This simplicity is only possible because of some simplifying
assumptions I made. I use global registers to store the return addresses
for coroutines. Those are a scarce resource even on SPARC, and this
approach won’t scale to more than 2 or 3 coroutines. We could work
around this by storing the return address in memory.</p>
<p>We were careful to nest the coroutines nicely, i.e.,
<code>_start</code> had a longer lifetime than <code>a</code> who had a
longer lifetime than <code>b</code>. That avoided awkward issues with
the stack pointer. We could even have used stack variables if we were
careful to save and restore the appropriate frame pointer. If we want to
lift the restriction on coroutine lifetime nesting, we’d have to
allocate separate memory for their stacks, and be careful about saving
and restoring the frame pointer. That’s not hard, but it’s definitely
more complicated than the simple approach in this post.</p>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>What better way to polish your résumé
than reading a 20+ year old book on a 30+ year old ISA that’s going to
be sunset in 5 or so years :^)<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>According to Knuth, the term has been
around since 1958.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Fun fact: early C++ had support for
coroutines because Bjarne’s background in simulation software written in
SIMULA.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>That’s a <em>very</em> hand wavy
explanation of what actually goes on. The actual process is quite
involved. The processor tracks the current register window index and
triggers a trap on overflow. The trap code uses the frame pointer to
decide what stack frame to use to spill the registers.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>The code on GitHub has macro
definitions for creating, yeilding and returning from coroutines.<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sat, 29 Apr 2023 13:00:00 +0000</pubDate>
</item>
<item>
<title>X macros in D</title>
<link>https://muscar.eu/posts/x-macros-in-dlang.html</link>
<description>X macros in D</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">X macros in D</h1>
<p class="author">Alex Muscar</p>
<p class="date">February 25, 2023</p>
</header>
<p>Recently, while migrating a project from C to D–I’ll write about it
at some point–I found myself missing <a
href="https://www.digitalmars.com/articles/b51.html">X macros</a>. As it
turns out, D has a pretty neat solution for this problem. And yes, it
involves metaprogramming :^).</p>
<h2 id="x-macros">X macros</h2>
<p>If you’re not familiar with X macros you can read more about them in
the article I linked, but here’s a quick introduction.</p>
<p>X macros solve the problem of keeping in sync related entities in a
program. In my case it’s instructions for an intermediate representation
(IR) in a compiler. I’ll use a simplified version as the running example
for the rest of this point. I’ll keep the technical details of my
particular problem relatively light, so we can focus on X macros.</p>
<p>My compiler generates the intermediate code in a byte buffer. It then
emits assembly code from the intermediate code in the buffer. The IR
instructions don’t have the same size. They take between one and five
bytes. Each instruction has a format that the backend of the compiler
uses to generate the assembly code for the instruction. Instructions are
identified by an opcode.</p>
<p>One (common) way to represent the instructions is to have an
<code>enum</code> for the opcodes, an array for the formats and another
one for sizes. Say we have three instructions:
<code>mov regd1, regs1</code>, <code>add regd1, regs1, regs2</code> and
<code>ret</code>. This is enough to illustrate the idea. The
straightforward implementation might look someting like (in
<code>ir.h</code>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    IR_MOV<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    IR_ADD<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    IR_RET<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    IR_OP_CNT</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>irfmts<span class="op">[</span>IR_OP_CNT<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;mov %r, %r&quot;</span><span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;add %r, %r, %r&quot;</span><span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ret&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> irsizes<span class="op">[</span>IR_OP_CNT<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span><span class="op">,</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span><span class="op">,</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The problem is that keeping the arrays in sync is error prone. Here’s
where X macros come in. By cleverly (ab-)using the C preprocessor we can
move the IR instruction declarations in a single file, say
<code>ir.inc</code>, and then get the arrays almost for free.</p>
<p>Here’s <code>ir.inc</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>XX<span class="op">(</span>IR_MOV<span class="op">,</span> <span class="st">&quot;mov %r, %r&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>XX<span class="op">(</span>IR_ADD<span class="op">,</span> <span class="st">&quot;add %r, %r, %r&quot;</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>XX<span class="op">(</span>IR_RET<span class="op">,</span> <span class="st">&quot;ret&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span></code></pre></div>
<p>Then in <code>ir.h</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define XX(OP, F, N) OP,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;ir.inc&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef XX</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    IR_OP_CNT</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>irfmts<span class="op">[</span>IR_OP_CNT<span class="op">]</span> <span class="op">=</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#define XX(OP, F, N) [OP] = F,</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;ir.inc&quot;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef XX</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> irsizes<span class="op">[</span>IR_OP_CNT<span class="op">]</span> <span class="op">=</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define XX(OP, F, N) [OP] = N,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;ir.inc&quot;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#undef XX</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The arrays are now generated automatically from the single
definition. This is one of the neater techniques involving the
preprocessor in C. What is particularly neat is that we have a single,
declarative definition of the instructions.</p>
<h2 id="the-d-solution">The D solution</h2>
<p>It wasn’t obvious if D supports anything similar to this pattern. I
suspected there’s something that could be done with metaprogramming, but
I could come up with a working solution.</p>
<p>Then I stumbled on <a
href="https://forum.dlang.org/post/tdqmi3$45r$1@digitalmars.com">this</a>
post in the D forum. Paul Backus’s solution is particularly well suited
for our scenario. The definition is now an array of structures with
custom attributes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="wa">struct</span> instr</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">string</span> fmt<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="wa">enum</span> IrOp</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    @instr<span class="op">(</span><span class="st">&quot;mov %r, %r&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span> Mov<span class="op">,</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    @instr<span class="op">(</span><span class="st">&quot;add %r, %r, %r&quot;</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span> Add<span class="op">,</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    @instr<span class="op">(</span><span class="st">&quot;ret&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> Ret<span class="op">,</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>@instr(...)</code> annotations are attributes attached to
the enum variants. To generate our arrays we can now use D’s powerful
metaprogramming:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> instrFmt<span class="op">(</span><span class="wa">alias</span> sym<span class="op">)()</span> <span class="op">=&gt;</span> getUDAs<span class="op">!(</span>sym<span class="op">,</span> instr<span class="op">)[</span><span class="dv">0</span><span class="op">]</span>.fmt<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> instrSize<span class="op">(</span><span class="wa">alias</span> sym<span class="op">)()</span> <span class="op">=&gt;</span> getUDAs<span class="op">!(</span>sym<span class="op">,</span> instr<span class="op">)[</span><span class="dv">0</span><span class="op">]</span>.size<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> instrFmts <span class="op">=</span> <span class="op">[</span>staticMap<span class="op">!(</span>instrFmt<span class="op">,</span> EnumMembers<span class="op">!</span>IrOp<span class="op">)];</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">auto</span> instrSizes <span class="op">=</span> <span class="op">[</span>staticMap<span class="op">!(</span>instrSize<span class="op">,</span> EnumMembers<span class="op">!</span>IrOp<span class="op">)];</span></span></code></pre></div>
<p>Now this is nice! Not only is just as declarative as the C version,
but it’s also safer. In C there’s no check if the <code>XX</code> params
are used correctly while generating the arrays. In D we access the
attribute properties by name.</p>
<p>And that’s it.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I didn’t come up with this technique. But I found it both useful, as
well as really neat. The more I use the language, the more nice
surprises like this one I stumble on. So far I’m digging D :^).</p>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Sat, 25 Feb 2023 21:34:51 +0000</pubDate>
</item>
<item>
<title>A Note on Binary Search and Overflows</title>
<link>https://muscar.eu/notes/note-on-binary-search-overflow.html</link>
<description>A Note on Binary Search and Overflows</description>
<content:encoded><![CDATA[<div id="home-link">
	<a href="https://muscar.eu">muscar.eu</a>
</div>
<header id="title-block-header">
<h1 class="title">A Note on Binary Search and Overflows</h1>
<p class="author">Alex Muscar</p>
<p class="date">January 04, 2024</p>
</header>
<p>I like reading old computing books and articles. I’m know I’m biased,
but “they don’t make them like they used to”. The other day I was
thumbing through Dijkstra’s “A Method of Programming”.</p>
<p>One of my hobby horses to look at binary search implementations, and
see if they have any of the common issues—off by ones, overflow, the
likes. And, as it happens, Dijkstra’s book has a chapter on binary
search. I didn’t expect there to be off by one errors —the whole book is
about deriving correct programs— but I was curious how he chose the
midpoint. It’s quite common to see something like of <span
class="math inline"><em>m</em> ← (<em>l</em>+<em>u</em>)/2</span>, where
<span class="math inline"><em>l</em></span> and <span
class="math inline"><em>u</em></span> pointers to the lower and upper
limits of the search interval.</p>
<p>This is OK in pseudocode since we don’t have to worry about overflows
in math. But it doesn’t work so well in the real world where integers
tend to be bounded. Long story short, <a
href="https://blog.research.google/2006/06/extra-extra-read-all-about-it-nearly.html">this
was a thing</a> in 2006.</p>
<p>Let’s see what Dijkstra had to say about overflows in 1988:</p>
<blockquote>
<p>Note that the correctness of our solution does not depend on whether
<span class="math inline"><em>d</em><em>i</em><em>v</em></span> is
rounded up or down, if rounding is necessary. We are completely at
liberty, therefore, to replace the assignment to <span
class="math inline"><em>h</em></span> by</p>
<p><span
class="math inline"><em>h</em> := <em>i</em> + (<em>j</em>−<em>i</em>) <em>d</em><em>i</em><em>v</em> 2</span></p>
<p>a version which should possibly be preferred with a view to
minimizing the chance of arithmetic overflow. Versions in which
termination depends critically on rounding conventions are unfortunately
not unusual in the literature.</p>
</blockquote>
<p>I guess it pays to read old books after all.</p>]]></content:encoded>
<author>Alex Muscar</author>
<pubDate>Thu, 04 Jan 2024 12:03:17 +0000</pubDate>
</item>
</channel>
</rss>
